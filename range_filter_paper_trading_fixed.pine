//@version=5
strategy("Range Filter - Paper Trading Strategy (Fixed JSON)", 
  overlay=true, pyramiding=1, 
  default_qty_type=strategy.fixed, default_qty_value=1, calc_on_every_tick=false)

// ------------------ Alert Configuration Inputs ------------------
alert_index = input.string("NIFTY", "Alert: Index Symbol", 
  tooltip="Symbol to use in alert JSON (e.g., NIFTY, BANKNIFTY)")
alert_order_type = input.string("MARKET", "Alert: Order Type", 
  options=["MARKET", "LIMIT"])
alert_product_type = input.string("INTRADAY", "Alert: Product Type", 
  options=["INTRADAY", "DELIVERY", "CNC", "INTRA"])
alert_validity = input.string("DAY", "Alert: Validity", 
  options=["DAY", "IOC"])
alert_lots = input.int(1, "Alert: Number of Lots", minval=1)
send_alerts = input.bool(true, "Enable Alert Notifications", 
  tooltip="Send JSON alerts for paper trading webhook")

// ------------------ User inputs (kept from original indicator) ------------------
src = input(defval=close, title="Source")
per = input.int(defval=100, minval=1, title="Sampling Period")
mult = input.float(defval=3.0, minval=0.1, title="Range Multiplier")

// ------------------ Helper functions & filter calculation ------------------
smoothrng(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    ta.ema(avrng, wper) * m

smrng = smoothrng(src, per, mult)

rngfilt(x, r) =>
    f = x
    f := x > nz(f[1]) ? x - r < nz(f[1]) ? nz(f[1]) : x - r :
         x + r > nz(f[1]) ? nz(f[1]) : x + r
    f

filt = rngfilt(src, smrng)

// Filter direction counts (same logic as indicator)
var float upward = 0.0
upward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])
var float downward = 0.0
downward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])

// Breakouts -> longCond / shortCond
longCond = (src > filt and src > src[1] and upward > 0) or (src > filt and src < src[1] and upward > 0)
shortCond = (src < filt and src < src[1] and downward > 0) or (src < filt and src > src[1] and downward > 0)

// Prevent immediate flip noise using CondIni logic from original
var int CondIni = 0
CondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]
// Allow a signal if previous confirmed side is NOT the same
longSignal = longCond and CondIni[1] != 1
shortSignal = shortCond and CondIni[1] != -1

// ------------------ Alert JSON Generator Function (FIXED) ------------------
// Generates JSON that matches paper trading webhook format exactly
generate_alert_json(side) =>
    '{"index":"' + alert_index + '","side":"' + side + '","order_type":"' + alert_order_type + '","price":' + str.tostring(close, "#.##") + ',"product_type":"' + alert_product_type + '","validity":"' + alert_validity + '","lots":' + str.tostring(alert_lots) + '}'

// ------------------ State Variables for Two-Step Execution ------------------
var int queued_action = 0  // 0=none, 1=queue_long, -1=queue_short
var int last_alert_bar = -999

// ------------------ Trading Logic (Two-Step Process) ------------------
// Step 1: Close current position on signal change (current candle)
// Step 2: Enter new position on next candle

if barstate.isconfirmed
    
    // === STEP 2: Execute queued entry (if any) ===
    if queued_action == 1 and strategy.position_size == 0
        // Enter long position
        strategy.entry("Long", strategy.long)
        if send_alerts and bar_index != last_alert_bar
            alert(generate_alert_json("BUY"), alert.freq_once_per_bar_close)
            last_alert_bar := bar_index
        queued_action := 0
    
    if queued_action == -1 and strategy.position_size == 0
        // Enter short position
        strategy.entry("Short", strategy.short)
        if send_alerts and bar_index != last_alert_bar
            alert(generate_alert_json("SELL"), alert.freq_once_per_bar_close)
            last_alert_bar := bar_index
        queued_action := 0
    
    // === STEP 1: Detect signal and close position (if needed) ===
    
    // LONG signal detected
    if longSignal
        if strategy.position_size < 0
            // Currently in short, close it first
            strategy.close("Short")
            if send_alerts and bar_index != last_alert_bar
                alert(generate_alert_json("BUY"), alert.freq_once_per_bar_close)
                last_alert_bar := bar_index
            // Queue long entry for next candle
            queued_action := 1
        else if strategy.position_size == 0 and queued_action == 0
            // No position, enter long immediately
            strategy.entry("Long", strategy.long)
            if send_alerts and bar_index != last_alert_bar
                alert(generate_alert_json("BUY"), alert.freq_once_per_bar_close)
                last_alert_bar := bar_index
    
    // SHORT signal detected
    if shortSignal
        if strategy.position_size > 0
            // Currently in long, close it first
            strategy.close("Long")
            if send_alerts and bar_index != last_alert_bar
                alert(generate_alert_json("SELL"), alert.freq_once_per_bar_close)
                last_alert_bar := bar_index
            // Queue short entry for next candle
            queued_action := -1
        else if strategy.position_size == 0 and queued_action == 0
            // No position, enter short immediately
            strategy.entry("Short", strategy.short)
            if send_alerts and bar_index != last_alert_bar
                alert(generate_alert_json("SELL"), alert.freq_once_per_bar_close)
                last_alert_bar := bar_index

// ------------------ Visual Indicators ------------------
// Plot the range filter
plot(filt, color=filt > filt[1] ? color.green : color.red, linewidth=2, title="Range Filter")

// Detect actual entry/exit actions
entry_long = strategy.position_size > 0 and strategy.position_size[1] == 0
entry_short = strategy.position_size < 0 and strategy.position_size[1] == 0
exit_position = strategy.position_size == 0 and strategy.position_size[1] != 0

// Plot actual entry signals
plotshape(entry_long, title="ENTERED Long", style=shape.labelup, 
  location=location.belowbar, color=color.new(color.green, 0), 
  text="BUY", textcolor=color.white, size=size.small)
plotshape(entry_short, title="ENTERED Short", style=shape.labeldown, 
  location=location.abovebar, color=color.new(color.red, 0), 
  text="SELL", textcolor=color.white, size=size.small)

// Plot exit signals
plotshape(exit_position, title="EXIT Position", style=shape.xcross, 
  location=location.abovebar, color=color.new(color.orange, 0), 
  text="EXIT", textcolor=color.white, size=size.tiny)

// Show queued actions
queued_long = queued_action == 1
queued_short = queued_action == -1
plotshape(queued_long, title="Queued Long", style=shape.triangleup, 
  location=location.bottom, color=color.new(color.lime, 50), size=size.tiny)
plotshape(queued_short, title="Queued Short", style=shape.triangledown, 
  location=location.top, color=color.new(color.orange, 50), size=size.tiny)

// ------------------ Alert Conditions (for manual alert creation) ------------------
// These are available when you create alerts manually in TradingView
// The main alerts are sent via alert() function in the code above
alertcondition(entry_long, title="ENTRY: Long Position Opened", 
  message="BUY entry executed")

alertcondition(entry_short, title="ENTRY: Short Position Opened", 
  message="SELL entry executed")

alertcondition(exit_position, title="EXIT: Position Closed", 
  message="Position closed")

